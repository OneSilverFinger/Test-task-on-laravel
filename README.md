# Система товарно-денежного учёта для ИП

Система товарно-денежного учёта для ИП с двумя магазинами на Laravel + MySQL.

## Возможности

- ✅ Учёт закупок у поставщиков и продаж покупателям
- ✅ Фиксация: кто, что и когда купил или продал
- ✅ Учёт дебиторской и кредиторской задолженности с поддержкой частичных оплат
- ✅ Учёт остатков товаров на складе в разрезе каждого магазина
- ✅ Учёт движения денежных средств и текущего остатка в кассе
- ✅ Поддержка различных единиц измерения товаров
- ✅ Полный интерфейс для ввода данных и просмотра отчётов
- ✅ Оптимизировано для работы с миллионами записей

## Требования

- Docker
- Docker Compose

## Установка

1. Запустите контейнеры:
```bash
docker-compose up -d --build
```

2. Установите зависимости Composer:
```bash
docker-compose exec app composer install
```

3. Создайте файл .env (если его нет):
```bash
# Windows PowerShell
Copy-Item .env.example .env

# Или Linux/Mac
cp .env.example .env
```

4. Сгенерируйте ключ приложения:
```bash
docker-compose exec app php artisan key:generate
```

5. Запустите миграции и сидеры:
```bash
docker-compose exec app php artisan migrate --seed
```

## Доступ к приложению

- Веб-приложение: http://localhost:8080
- MySQL: localhost:3306
  - Database: laravel
  - Username: laravel
  - Password: root
  - Root Password: root

## Использование

### Начальные данные

После выполнения миграций с сидерами будут созданы два магазина:
- Магазин №1
- Магазин №2

### Работа с системой

1. **Справочники:**
   - Создайте поставщиков, покупателей и товары через соответствующие разделы

2. **Закупки:**
   - Создайте закупку у поставщика
   - Система автоматически обновит остатки на складе выбранного магазина
   - Добавьте оплаты закупки (можно частично)

3. **Продажи:**
   - Создайте продажу покупателю
   - Система автоматически проверит остатки и обновит их
   - Добавьте оплаты продажи (можно частично)

4. **Отчёты:**
   - Остатки товаров - просмотр остатков по магазинам
   - Задолженности - дебиторская и кредиторская задолженность
   - Движение товаров - история всех операций с товарами
   - Движение денег - история операций с денежными средствами

### Особенности производительности

- Индексы на всех ключевых полях для быстрых запросов
- Составные индексы для сложных запросов
- Оптимизированные запросы с использованием отношений Eloquent
- Пагинация для больших объёмов данных

## Тестирование

Подробный план тестирования находится в файле `TESTING.md`. 

Быстрый старт:
1. Откройте http://localhost:8080 в браузере
2. Создайте поставщика, покупателя и несколько товаров
3. Создайте закупку - остатки обновятся автоматически
4. Создайте продажу - система проверит остатки
5. Добавьте оплаты (можно частично)
6. Проверьте отчёты

## Команды

### Выполнение Artisan команд
```bash
docker-compose exec app php artisan [command]
```

### Выполнение Composer команд
```bash
docker-compose exec app composer [command]
```

### Остановка контейнеров
```bash
docker-compose down
```

### Остановка с удалением volumes
```bash
docker-compose down -v
```

## Структура проекта

- `app/Models/` - Eloquent модели
- `app/Http/Controllers/` - Контроллеры
- `app/Services/` - Бизнес-логика (управление остатками, заказами)
- `database/migrations/` - Миграции БД
- `resources/views/` - Blade шаблоны
- `routes/web.php` - Маршруты приложения

## Структура базы данных

### Основные таблицы

#### Справочники
- **stores** - Магазины (2 магазина по умолчанию)
- **suppliers** - Поставщики
- **customers** - Покупатели
- **products** - Товары с единицами измерения

#### Документы закупок
- **purchase_orders** - Закупки у поставщиков
  - `total_amount` - общая сумма заказа
  - `paid_amount` - оплаченная сумма
  - `debt_amount` - задолженность (total - paid)
- **purchase_order_items** - Позиции закупок
  - `quantity` - количество в базовой единице товара
  - `price` - цена за единицу
  - `total` - итого по позиции
- **purchase_payments** - Оплаты по закупкам

#### Документы продаж
- **sale_orders** - Продажи покупателям
  - `total_amount` - общая сумма заказа
  - `paid_amount` - оплаченная сумма
  - `debt_amount` - задолженность (total - paid)
- **sale_order_items** - Позиции продаж
  - `quantity` - количество в базовой единице товара
  - `price` - цена за единицу
  - `total` - итого по позиции
- **sale_payments** - Оплаты по продажам

#### Учёт остатков и движений
- **inventory** - Текущие остатки товаров по магазинам
  - Уникальный индекс на `(store_id, product_id)` - один остаток на товар в магазине
  - `quantity` - остаток в базовой единице товара
- **stock_movements** - История всех движений товаров
  - `type` - тип движения (purchase/sale/adjustment)
  - `quantity` - положительное для прихода, отрицательное для расхода
  - `quantity_after` - остаток после операции
- **cash_movements** - Движение денежных средств
  - `type` - приход/расход (income/expense)
  - `category` - категория (sale_payment/purchase_payment/other)

### Архитектурные решения

#### 1. Раздельный учёт остатков по магазинам
**Почему:** Каждый магазин имеет свой склад, остатки независимы.
- Таблица `inventory` с уникальным ключом `(store_id, product_id)`
- При закупке/продаже остаток обновляется только для выбранного магазина

#### 2. Две таблицы для остатков и движений
**Почему:** Компромисс между производительностью и историей.
- **inventory** - денормализованная таблица для быстрого доступа к текущим остаткам
- **stock_movements** - нормализованная таблица истории для отчётов
- При каждой операции обновляются обе таблицы в транзакции

#### 3. Хранение задолженностей в документах
**Почему:** Для быстрого расчёта без агрегации при каждом запросе.
- `debt_amount` хранится в `purchase_orders` и `sale_orders`
- Пересчитывается при добавлении каждой оплаты
- Индекс на `debt_amount` для фильтрации документов с задолженностью

#### 4. Все количества в базовой единице товара
**Почему:** Упрощает расчёты и избегает ошибок конвертации.
- В `products.unit` хранится единица измерения (шт, кг, м и т.д.)
- Все операции с количествами в одной единице
- Отображение единицы только для UI

#### 5. Поддержка частичных оплат
**Почему:** В реальности оплаты часто происходят частями.
- Множественные записи в `purchase_payments` / `sale_payments`
- Автоматический пересчёт `paid_amount` и `debt_amount`
- Ограничение максимальной суммы оплаты на уровне UI

#### 6. История движений товаров
**Почему:** Для аудита и отчётов.
- Каждое движение фиксируется в `stock_movements`
- Хранится остаток до и после операции
- Связь с исходным документом через `reference_type` и `reference_id`

#### 7. Движение денег отдельной таблицей
**Почему:** Для контроля кассы и финансовых отчётов.
- Все операции с деньгами в `cash_movements`
- Связь с оплатами через `reference_type` и `reference_id`
- Быстрый расчёт остатка кассы через SUM

### Оптимизация производительности

#### Индексы для быстрых запросов:

1. **Составные индексы для частых фильтров:**
   - `purchase_orders`: `(supplier_id, order_date)`, `(store_id, order_date)`
   - `sale_orders`: `(customer_id, order_date)`, `(store_id, order_date)`
   - `stock_movements`: `(store_id, product_id, movement_date)`

2. **Индексы для поиска:**
   - `products`: `(name, is_active)`, `sku` (unique)
   - `purchase_orders.number`, `sale_orders.number` (unique)

3. **Индексы для отчётов:**
   - `inventory.quantity` - для поиска товаров с остатками
   - `stock_movements.movement_date` - для фильтрации по датам
   - `cash_movements.movement_date` - для финансовых отчётов

4. **Уникальные ограничения:**
   - `inventory`: `(store_id, product_id)` - один остаток на товар в магазине

#### Типы данных для точности:

- `DECIMAL(15, 4)` для количеств - точность до 0.0001 (важно для кг, литров)
- `DECIMAL(15, 2)` для денежных сумм - точность до копеек
- `DATE` для дат - без времени для упрощения отчётов

## Особенности реализации

### 1. Транзакционность операций

Все операции с остатками и оплатами выполняются в транзакциях:
- При создании закупки/продажи: обновление остатков и создание движения атомарно
- При добавлении оплаты: обновление задолженности и создание движения денег атомарно

Это гарантирует целостность данных даже при ошибках.

### 2. Проверка остатков при продаже

```php
if ($currentQuantity < $quantity) {
    throw new \Exception("Недостаточно товара на складе...");
}
```

Проверка выполняется перед уменьшением остатка, предотвращая продажу несуществующего товара.

### 3. Автоматический расчёт задолженностей

При добавлении оплаты:
- `paid_amount = old_paid + new_payment`
- `debt_amount = max(0, total_amount - paid_amount)`

Задолженность всегда >= 0, переплаты исключены.

### 4. Eager Loading для производительности

Все запросы используют `with()` для предзагрузки связанных моделей:
```php
PurchaseOrder::with(['supplier', 'store', 'items.product'])
```

Избегаем проблемы N+1 запросов.

### 5. Пагинация для больших объёмов

Все списки используют пагинацию:
- Закупки/продажи: 50 на странице
- Отчёты: 100 на странице

Это критично при работе с миллионами записей.

### 6. Мягкая проверка остатков

Остатки могут стать отрицательными только при ошибке в коде. В продакшене можно добавить триггеры БД или события Laravel для дополнительной защиты.

### 7. Масштабируемость

Система спроектирована для работы с большими объёмами:
- Индексы позволяют быстро находить данные
- Отдельная таблица остатков ускоряет запросы
- История движений не замедляет текущие операции
- Можно добавить партиционирование `stock_movements` по датам при необходимости

### 8. Архитектура сервисов

Бизнес-логика вынесена в сервисы:
- `InventoryService` - управление остатками
- `OrderService` - создание заказов и оплат

Это упрощает тестирование и переиспользование кода.

### 9. Нумерация документов

Автоматическая генерация номеров:
- Закупки: `PO-20241214-0001`
- Продажи: `SO-20241214-0001`

Уникальность через индекс в БД.

### 10. Гибкость единиц измерения

Товары могут иметь любую единицу (шт, кг, м, л и т.д.), все расчёты выполняются в числовом виде, единица используется только для отображения.

